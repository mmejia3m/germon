{
  "name": "mikronode",
  "description": "Mikrotik API implemented in Node",
  "version": "0.3.3",
  "author": {
    "name": "Brandon Myers",
    "email": "trakkasure@gmail.com"
  },
  "contributors": [
    {
      "name": "Brandon Myers",
      "email": "trakkasure@gmail.com"
    }
  ],
  "keywords": [
    "mikrotik",
    "socket",
    "api"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/trakkasure/mikronode"
  },
  "bugs": "https://github.com/Trakkasure/mikronode/issues",
  "main": "lib/index",
  "engines": {
    "node": ">= 0.3.8"
  },
  "readme": "# Mikronode\n      \n  Full-Featured asynchronous Mikrotik API interface for [NodeJS](http://nodejs.org).\n  \n     var api = require('mikronode');\n     \n     var connection = new api('192.168.0.1','admin','password');\n     connection.connect(function(conn) {\n\n        var chan=conn.openChannel();\n\n        chan.write('/ip/address/print',function() {\n           chan.on('done',function(data) {\n\n              var parsed = api.parseItems(data);\n\n              parsed.forEach(function(item) {\n                 console.log('Interface/IP: '+item.interface+\"/\"+item.address);\n              });\n\n              chan.close();\n              conn.close();\n\n           });\n        });\n     });\n\n## Installation\n\n  Clone this repository into your node_modules directory.\n  - or -\n     $ npm install mikronode\n\n\n## Features\n\n  * Channel based communication\n  * Multiple channels can be used at once.\n  * Synchronous execution of commands issued on the same channel.\n  * Asynchrounous execution of commands issued on different channels.\n  * Focus on high performance\n\n## TODO\n  * Cleanup login section in connect method.\n  * Re-design code to hide internal methods and variables.\n  * Write tests con make sure everything keeps working while making above changes.\n\n## API\n\n### Connection\n\n  Calling new api(host,user,pass) returns a connection object.\n\n  * conn.connect(callback)  \n      Connect to the target device. The callback function is called after successful login with the current connection object as its parameter.\n  * conn.openChannel(id)  \n      Open and return a new channel object. Each channel is a unique command line to the mikrotik, allowing simultaneous execution of commands. The ID parameter is optional.\n  * conn.connected()  \n      Returns true is currently connected to a mikrotik device.\n  * conn.closeChannel(id)  \n      Closes an open channel. This will call the close method of the channel object.\n  * conn closeOnDone(b)  \n      If b == true, when a done event occurs, close the connection after all channels have been closed.\n  * conn.close(force)  \n      Close the connection. If force is true, force close of any open channels then close this connection.\n  * conn.getHost()\n  * conn.getUser()\n\n\n### Channel\n\n  The following methods are available for channels:\n\n  * channel.closeOnDone(b)\n      If b == true, when a done event occurs, close the channel after all commands queued have been executed.\n  * channel.saveBuffer(b)  \n      If b is true, then save each line received in a buffer and pass the entire buffer to the done event. Otherwise the done event will not get all the lines, only the last line.  \n      This is handy when following trailing output from a listen command, where the data could be endless.\n  * channel.getConnection()\n  * channel.getId()\n  * channel.write(lines,writeCallback)  \n      Lines can be a string, or an array of strings. If it is a string, then it is split on the EOL character and each resulting line is sent as a separate word (in API speak)\n      If lines is an array, then each element is sent unaltered.\n  * channel.close(force)  \n      Close the channel. If there are any commands still waiting to be executed, they will be completed before closing the channel.  \n      If force is TRUE, then the channel is immediately closed. If the channel is running, the cancel command is sent to stop any running listen commands, or potentially long running output.\n\n## Examples\n\n### Connect to a Mikrotik, and add an address to ether1\n\n     var api = require('mikronode');\n\n     var connection = new api('192.168.0.1','admin','password');\n     connection.connect(function(conn) {\n\n        var chan=conn.openChannel();\n\n        chan.write(['/ip/address/add','=interface=ether1','=address=192.168.1.1'],function() {\n           chan.on('trap',function(data) {\n              console.log('Error setting IP: '+data);\n           });\n           chan.on('done',function(data) {\n              console.log('IP Set.');\n           });\n           chan.close();\n           conn.close();\n        });\n     });\n\n### Writing the program for the example API conversation on the [Mikrotik Wiki](http://wiki.mikrotik.com/wiki/API#.2Fcancel.2C_simultaneous_commands)\n\n     var api = require('mikronode');\n\n     var connection = new api('192.168.0.1','admin','password');\n     connection.connect(function(conn) {\n\n        conn.closeOnDone(true);\n        var chan2=conn.openChannel(2);\n        chan2.write('/interface/listen',function(chan) {\n           chan.on('read',function(data) {\n              packet=api.parseItems([data])[0];\n              console.log('Interface change: '+JSON.stringify(packet));\n           });\n        });\n\n        var chan3=conn.openChannel(3);\n        chan3.closeOnDone(true);\n\n        chan3.write(['/interface/set','=disabled=yes','=.id=ether1'],function(chan) {\n           chan.on('done',function(d,chan) {\n              // We do this here, 'cause we want channel 4 to write after channel 3 is done.\n              var chan4=conn.openChannel(4); // We'll use this later.\n              chan4.closeOnDone(true);\n              chan4.write(['/interface/set','=disabled=no','=.id=ether1'],function() {\n                var chan5=conn.openChannel(5); \n                chan5.closeOnDone(true);\n                chan5.write('/interface/getall',function(chan) {\n                   chan.on('done',function(data) {\n                      packets=api.parseItems(data);\n                      packets.forEach(function(packet) {\n                          console.log('Interface: '+JSON.stringify(packet));\n                      });\n                      chan2.close(); // This should call the /cancel command to stop the listen.\n                   });\n                });\n              })\n           });\n        });\n     });\n\n### Simplifying the above by reducing the number of channels.\n  Notice how the callback embedding is not needed using the syncronous capability.\n\n     var api = require('mikronode');\n\n     var connection = new api('192.168.0.1','admin','password');\n     connection.connect(function(conn) {\n\n        conn.closeOnDone(true); // All channels need to complete before the connection will close.\n        var listenChannel=conn.openChannel();\n        listenChannel.write('/interface/listen',function(chan) {\n           chan.on('read',function(data) {\n              packet=api.parseItems([data])[0];\n              console.log('Interface change: '+JSON.stringify(packet));\n           });\n        });\n\n        var actionChannel=conn.openChannel();\n        // These will run synchronsously\n        actionChannel.write(['/interface/set','=disabled=yes','=.id=ether1']); // don't care to do anything after it's done.\n        actionChannel.write(['/interface/set','=disabled=no','=.id=ether1']); // don't care to do anything after it's done.\n        actionChannel.write('/interface/getall',function(chan) {\n           chan.on('done',function(data) {\n              packets=api.parseItems(data);\n              packets.forEach(function(packet) {\n                  console.log('Interface: '+JSON.stringify(packet));\n              });\n              listenChannel.close(); // This should call the /cancel command to stop the listen.\n           });\n        });\n        actionChannel.close(); // The above commands will complete before this is closed.\n     });\n\n\n  The method *decodeLength* and *encodeString* were written based on code [here on the Mikrotik Wiki](http://wiki.mikrotik.com/wiki/API_PHP_class#Class).\n  \n## License\n\n(The MIT License)\n\nCopyright (c) 2011 Brandon Myers <trakkasure@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n",
  "readmeFilename": "Readme.md",
  "_id": "mikronode@0.3.3",
  "_from": "mikronode@"
}
